# These functions are almost invariably used only interactively,
# thus they go into `.bashrc`.

#   Is Git version on this host >= given version?
__git_tools_gitver_GE() {
    local vs=($(git --version | sed -e 's/git version //' -e 's/\./ /g'))
    local ws=($(echo "$@" | sed -e 's/\./ /g'))
    # For `-lt`, empty string is 0
    [[ ${vs[0]} -lt ${ws[0]} ]] && return 1
    [[ ${vs[1]} -lt ${ws[1]} ]] && return 1
    [[ ${vs[2]} -lt ${ws[2]} ]] && return 1
    [[ ${vs[3]} -lt ${ws[3]} ]] && return 1
    return 0
}

############################################################
# git log, diff, other repo search/browse/etc. functions

log()  { git log "$@"; }

logb() {        # brief graph of current or specified branches
    # Use `-S` in less to switch to wrapped lines instead of sideways scrolling
    LESS="$LESS -SR" \
    git log --graph --abbrev-commit --pretty=oneline --decorate=short "$@"
}

logab() {       # brief graph of all branches
    local exclude_notes='--exclude=refs/notes/\*'
    __git_tools_gitver_GE 1.8 || exclude_notes=
    logb --all $exclude_notes "$@"
}

logh() {        # the "head" of the repo
    #   The idea is to get a quick overview of the relationships between
    #   the tips of recent branches that are at least moderately closely
    #   related to HEAD (or master?). This method of selecting the commits
    #   and limiting the number shown could probably be improved. In
    #   particular, it would be nice to show a bit of HEAD no matter how
    #   old it is.
    LESS="$LESS -E" logab --since '1 week ago' -n 30 "$@";
}

logm() {        # brief graph with commit metadata
    local sha='%C(auto)%h'
    # Truncated relative works better for quick review than %ad
    local date='%C(green)%<(12,trunc)%ar%C(auto)'
    local author='%C(black)%<(20,trunc)%ae%C(auto)'
    local branches='%C(auto)% D'
    local subject='%n%C(blue)%s'

    local format="$sha $date $author$branches$subject"
    logb --pretty="tformat:$format" "$@"
}

logmn() {       # logm without merges
    logm --no-merges "$@"
}

logs() {        # full paths of changed files
    git log --stat=999 --stat-graph-width=5 "$@"
}

logp() {        # log with patches
                # changed paths are truncated in stat, full in diff
    git log --stat -p "$@"
}

logp1() {       # most recent patch
    logp -1 "$@"
}

blame() { git blame "$@"; }

slp1() {        # most recent patch with leading blank lines for readability
    local i; for i in 1 2 3 4 5; do echo; done
    logp1 "$@"
}

dif()   { git diff "$@"; }
difs()  { dif --cached "$@"; }          # `--staged` not in old Git versions
dift()  { git difftool -y "$@"; }

ggrep()         { git grep "$@"; }
gfgrep()        { ggrep -F "$@"; }

gk()            {
    [ -n "$1" ] && { start="--select-commit=$1"; shift; }
    [ -n "$1" ] && { echo 1>&2 'Usage: gk [start-commitish]'; return 2; }
    gitk --all "$start";
}


############################################################
# git checkout, stage, commit

co()        { git checkout "$@"; }

# Nasty completion hack; this just calls the completion for "git checkout".
complete -r co 2>/dev/null  # Perhaps not necessary given all options below?
[ -f /usr/share/bash-completion/completions/git ] && {
    # Ensure we have __git_wrap__git_main
    source /usr/share/bash-completion/completions/git

    # Generated by http://superuser.com/a/437508/26274
    function _alias_completion::co {
                            (( COMP_CWORD += 1 ))
                            COMP_WORDS=(git checkout ${COMP_WORDS[@]:1})
                            (( COMP_POINT -= ${#COMP_LINE} ))
                            COMP_LINE=${COMP_LINE/co/git checkout}
                            (( COMP_POINT += ${#COMP_LINE} ))
                            __git_wrap__git_main
                        }
    complete -o bashdefault -o default -o nospace -F _alias_completion::co co
}

add()       { git add "$@"; }

com()       { git commit -v "$@"; }
coma()      {
                # If we have changes staged in the index, assume we don't
                # want to commit unstaged changes.
                local _a=''
                git diff-index --quiet --cached HEAD -- && _a='-a'
                com $_a "$@";
            }
camend()    { com --amend "$@"; }
cpick()     { git cherry-pick "$@"; }

############################################################
# git branch

br() {
    local bropts grep_args=()
    while :; do case "$1" in
        -a) shift; bropts="-a -v";;
        -v) shift; bropts="-v";;
        -g) shift; grep_args+=("$1"); shift;;
        *)  break;;
    esac; done
    # Using '.' as the default grep argument will remove blank lines.
    # We can live with this here, since we expect none.
    git branch --color $bropts "$@" \
        | grep "${grep_args[@]:-.}" \
        | less -E -R -S -J
}
bra()           { br -a "$@"; }
brag()          { br -a -g "$@"; }
brv()           { br -v "$@"; }

# See co() above for more on this completion hack
[ -f /usr/share/bash-completion/completions/git ] && {
    function _alias_completion::br {
                            (( COMP_CWORD += 1 ))
                            COMP_WORDS=(git branch ${COMP_WORDS[@]:1})
                            (( COMP_POINT -= ${#COMP_LINE} ))
                            COMP_LINE=${COMP_LINE/br/git branch}
                            (( COMP_POINT += ${#COMP_LINE} ))
                            __git_wrap__git_main
                        }
    complete -o bashdefault -o default -o nospace -F _alias_completion::br br
}

mbase() {
    local range_to=false
    [ _"$1" = _-t ] && { range_to=true; shift; }
    local here=${1:-HEAD}
    local there=${2:-origin/master}

    local base=$(git merge-base "$here" "$there")
    if $range_to; then
        echo "$base..$here"
    else
        echo "$base"
    fi
}

############################################################
# git rebase, reset, similar

mergeff()       { git merge --ff-only "$@"; }   # Should be `integrate`?

gr()            { git rebase "$@"; }
grm()           { git rebase "$@" origin/master; }
grabort()       { git rebase --abort "$@"; }
grcontinue()    { git rebase --continue "$@"; }
grskip()        { git rebase --skip "$@"; }
grwhere()       { logb ORIG_HEAD HEAD --not $(git merge-base ORIG_HEAD HEAD)^; }
gri()           {
    local arg=${1:-10}                  # default: 10 commits back
    [ $arg -lt 1000 ] 2>/dev/null \
        && git rebase -i "HEAD~$arg" \
        || git rebase -i "$arg^"
}

gre()           { git reset "$@"; }
grehard()       { git reset -q --hard "$@" \
                  && echo 'Current and previous locations:' \
                  && git reflog show -2 #'HEAD@{1}'
                }
greupstream()   { grehard '@{upstream}'; }

stash()         { if [ "$1" = "" ]
                    then echo; git stash list
                    else git stash "$@"
                    fi
                }

############################################################
# git remote operations

# Most of these are planned to have further additional functionality,
# e.g., having `fetch` be able to take a list of paths to
# repos/workdirs and fetch in each of them.

#   List fetch URLs for the repos given on the command line.
#   Options:
#       -o  Show `origin` push URL only
gurl()  {
    local origin_only=''
    [[ $1 = -o ]] && { shift; origin_only='/^origin[[:space:]]/!d'; }
    [[ -n $1 ]] || set .    # default arg
    for dir in "$@"; do
        git -C "$dir" remote -v | sed \
            -e '/ (push)$/d' \
            -e 's/ (fetch)$//' \
            -e "$origin_only" \
            -e 's/^[^[:blank:]]*[[:space:]]*//'
    done
}

rem()   {
    if [[ ${#@} -gt 0 ]]; then
        git remote "$@"
    else
        # List all remotes with their push URLs.
        local rems
        mapfile -t rems < <(git remote)
        for rem in "${rems[@]}"; do
            printf "%s %s\n" "$rem" "$(git remote get-url --push "$rem")"
        done | column -t
    fi
}

# Given no args, fetch from remotes.default or, if not set, all remotes.
# Otherwise fetch from all listed remotes/`remotes.<group>` entries.
#
fetch() {
    git remote update "$@";
}

pull()  { git pull "$@"; }

gprune()        { git remote prune "$@" $(git remote); }

# Disallow use of -f and --force. If `pushf` doesn't work for you, you
# can use `git push --force`.
#
push()          {
    for i in "$@"; do case "$i" in
        -f)      echo 1>&2 "Do not use -f option, use pushf"; return 1;;
        --force) echo 1>&2 "Do not use --force option, use pushf"; return 1;;
    esac; done
    git push "$@";
}

pushf()         {
    for i in "$@"; do case "$i" in
        -f) echo 1>&2 "Do not use -f option, use --force"; return 1;;
    esac; done
    git push --force-with-lease "$@";
}

# Create upstream branch in remote.
# XXX This should be able to figure out a default remote.
#
pushu()         {
    # XXX This doesn't properly handle arguments before the <remote>
    [ -z "$1" ] && { echo 1>&2 "Usage: pushu <remote> [<branch>]"; return 2; }
    local -a argv=("$1"); shift
    [ -z "$1" ] && argv+=($(git rev-parse --abbrev-ref=strict HEAD))
    for i in "$@"; do argv+=("$i"); done
    git branch --unset-upstream || true
    push --set-upstream "${argv[@]}"
}
