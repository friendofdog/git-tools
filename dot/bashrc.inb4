# These functions are almost invariably used only interactively,
# thus they go into `.bashrc`.

############################################################
# git log

logb() {        # brief graph of current or specified branches
    # Use `-S` in less to switch to wrapped lines instead of sideways scrolling
    LESS="$LESS -SR" \
    git log --graph --abbrev-commit --pretty=oneline --decorate=short "$@"
}

logab() {       # brief graph of all branches
    # XXX Needs to drop --exclude on earlier versions of Git
    logb --all --exclude=refs/notes/* "$@"
}

logh() {        # the "head" of the repo
    #   The idea is to get a quick overview of the relationships between
    #   the tips of recent branches that are at least moderately closely
    #   related to HEAD (or master?). This method of selecting the commits
    #   and limiting the number shown could probably be improved. In
    #   particular, it would be nice to show a bit of HEAD no matter how
    #   old it is.
    LESS="$LESS -E" logab --since '1 week ago' -n 30 "$@";
}

logm() {        # brief graph with commit metadata
    local sha='%C(auto)%h'
    # Truncated relative works better for quick review than %ad
    local date='%C(green)%<(12,trunc)%ar%C(auto)'
    local author='%C(black)%<(20,trunc)%ae%C(auto)'
    local branches='%C(auto)% D'
    local subject='%n%C(blue)%s'

    local format="$sha $date $author$branches$subject"
    logb --pretty="tformat:$format" "$@"
}

logmn() {       # logm without merges
    logm --no-merges "$@"
}

logs() {        # full paths of changed files
    git log --stat=999 --stat-graph-width=5 "$@"
}

logp() {        # log with color word-diff patches
                # changed paths are truncated in stat, full in diff
    git log --stat -p --word-diff=color "$@"
}

logp1() {       # most recent patch
    logp -1 "$@"
}

slp1() {        # most recent patch with leading blank lines for readability
    local i; for i in 1 2 3 4 5; do echo; done
    logp1 "$@"
}

############################################################
# git remote operations

# Most of these are planned to have further additional functionality,
# e.g., having `fetch` be able to take a list of paths to
# repos/workdirs and fetch in each of them.

rem()   {
    if [[ ${#@} -gt 0 ]]; then
        git remote "$@"
    else
        # List all remotes with their push URLs.
        local rems
        mapfile -t rems < <(git remote)
        for rem in "${rems[@]}"; do
            printf "%s %s\n" "$rem" "$(git remote get-url --push "$rem")"
        done | column -t
    fi
}

# Given no args, fetch from remotes.default or, if not set, all remotes.
# Otherwise fetch from all listed remotes/`remotes.<group>` entries.
#
fetch() {
    git remote update "$@";
}

pull()  { git pull "$@"; }

# Disallow use of -f and --force. If `pushf` doesn't work for you, you
# can use `git push --force`.
#
push()          {
    for i in "$@"; do case "$i" in
        -f)      echo 1>&2 "Do not use -f option, use pushf"; return 1;;
        --force) echo 1>&2 "Do not use --force option, use pushf"; return 1;;
    esac; done
    git push "$@";
}

pushf()         {
    for i in "$@"; do case "$i" in
        -f) echo 1>&2 "Do not use -f option, use --force"; return 1;;
    esac; done
    git push --force-with-lease "$@";
}

# Create upstream branch in remote.
# XXX This should be able to figure out a default remote.
#
pushu()         {
    # XXX This doesn't properly handle arguments before the <remote>
    [ -z "$1" ] && { echo 1>&2 "Usage: pushu <remote> [<branch>]"; return 2; }
    local -a argv=("$1"); shift
    [ -z "$1" ] && argv+=($(git rev-parse --abbrev-ref=strict HEAD))
    for i in "$@"; do argv+=("$i"); done
    push --set-upstream "${argv[@]}"
}
